personality01  
	Check that we can set the personality for a process.
personality02  
	Check that we get EINVAL for a bad personality.
exit01  
	Check that exit returns the correct values to the waiting parent
exit02  
	Check that exit flushes output file buffers and closes files upon
	exiting
wait02
	Basic test for wait(2) system call. 
wait401  
	check that a call to wait4() correctly waits for a child
	process to exit
wait402  
	check for ECHILD errno when using an illegal pid value

waitpid01  
	Check that when a child kills itself by generating an alarm
	exception, the waiting parent is correctly notified.
waitpid02  
	Check that when a child kills itself by generating an integer zero
	divide exception, the waiting parent is correctly notified.
waitpid03  
	Check that parent waits until specific child has returned.
waitpid04  
	test to check the error conditions in waitpid sys call
waitpid05  
	Check that when a child kills itself with a kill statement after
	determining its process id by using getpid, the parent receives a
	correct report of the cause of its death. This also indirectly
	checks that getpid returns the correct process id.
waitpid06  
	Tests to see if pid's returned from fork and waitpid are same.
waitpid07  
	Tests to see if pid's returned from fork and waitpid are same.
waitpid08  
	Tests to see if pid's returned from fork and waitpid are same
waitpid09  
	Check ability of parent to wait until child returns, and that the
	child's process id is returned through the waitpid. Check that
	waitpid returns immediately if no child is present.
waitpid10  
	Tests to see if pid's returned from fork and waitpid are same
waitpid11  
	Tests to see if pid's returned from fork and waitpid are same
waitpid12  
	Tests to see if pid's returned from fork and waitpid are same
waitpid13  
	Tests to see if pid's returned from fork and waitpid are same
fcntl01  
	Test F_DUPFD, F_SETFL cmds of fcntl
fcntl02
	Basic test for fcntl(2) using F_DUPFD argument.
fcntl03
	Basic test for fcntl(2) using F_GETFD argument.
fcntl04
	Basic test for fcntl(2) using F_GETFL argument. 
fcntl05
	Basic test for fcntl(2) using F_GETLK argument. 
fcntl06  
	Error checking conditions for remote locking of regions of a file.
fcntl07
	Close-On-Exec functional test. 
fcntl07B
	Close-On-Exec of named pipe functional test. 
fcntl08
	Basic test for fcntl(2) using F_SETFL argument. 
fcntl09
	Basic test for fcntl(2) using F_SETLK argument. 
fcntl10
	Basic test for fcntl(2) using F_SETLKW argument. 
fcntl11  
	Testcase to check locking of regions of a file

fcntl12  

	Testcase to test that fcntl() sets EMFILE for F_DUPFD command.

fcntl13  

	Testcase to test that fcntl() sets errno correctly.

fcntl14  

	File locking test cases for fcntl. In Linux, S_ENFMT is not implemented
	in the kernel. However all standard Unix kernels define S_ENFMT as
	S_ISGID. So this test defines S_ENFMT as S_ISGID.

fcntl15  

	Check that file locks are removed when file closed

fcntl16  

	Additional file locking test cases for checking proper notification
	of processes on lock change

fcntl17  

	Check deadlock detection for file locking

fcntl18  

	Test to check the error conditions in fcntl system call

fcntl19  

	Testcase to check locking of regions of a file

fcntl20  

	Check locking of regions of a file

fcntl21  

	Check locking of regions of a file

dup01		

	Basic test for dup(2).

dup02		 	

	Negative test for dup(2) with bad fd.

dup03

	Negative test for dup(2) (too many fds).

dup04

	Basic test for dup(2) of a system pipe descriptor.

dup05

	Basic test for dup(2) of a named pipe descriptor. 

dup201  

	Negative tests for dup2() with bad fd (EBADF), and for "too many
	open files" (EMFILE)

dup202  

	Is the access mode the same for both file descriptors?
	0: read only ?	"0444"
	1: write only ? "0222"
	2: read/write ? "0666"

dup203  

	Testcase to check the basic functionality of dup2().

dup204  

	Testcase to check the basic functionality of dup2(2).


msync01  

	Verify that, msync() succeeds, when the region to synchronize, is part
	of, or all of a mapped region.

msync02  

	Verify that msync() succeeds when the region to synchronize is mapped
	shared and the flags argument is MS_INVALIDATE.

msync03  

	Verify that, msync() fails, when the region to synchronize, is outside
	the address space of the process.

msync04  

	Verify that, msync() fails, when the region to synchronize, is mapped
	but the flags argument is invalid.

msync05  

	Verify that, msync() fails, when the region to synchronize, was not
	mapped.


sendfile02  

	Testcase to test the basic functionality of the sendfile(2) system call.

sendfile03  

	Testcase to test that sendfile(2) system call returns appropriate
	errnos on error.

fork01
	Basic test for fork(2). 
fork02  
	Test correct operation of fork:
	pid == 0 in child;
	pid > 0 in parent from wait;
fork03  
	Check that child can use a large text space and do a large
	number of operations.	
fork04
	Child inheritance of Environment Variables after fork(). 
fork05
	Make sure LDT is propagated correctly 
fork06  
	Test that a process can fork children a large number of
	times in succession
fork07  
	Check that all children inherit parent's file descriptor
fork08  
	Check if the parent's file descriptors are affected by 
	actions in the child; they should not be.
fork09  
	Check that child has access to a full set of files.
fork10  
	Check inheritance of file descriptor by children, they
	should all be referring to the same file.
fork11  
	Test that parent gets a pid from each child when doing wait
vfork01  
	Fork a process using vfork() and verify that, the attribute values like
	euid, ruid, suid, egid, rgid, sgid, umask, inode and device number of
	root and current working directories are same as that of the parent 
	process.
vfork02  
	Fork a process using vfork() and verify that, the pending signals in
	the parent are not pending in the child process.
ioctl01  

	Testcase to check the errnos set by the ioctl(2) system call.

ioctl02  

	Testcase to test the TCGETA, and TCSETA ioctl implementations for
	the tty driver

sockioctl01  

	Verify that ioctl() on sockets returns the proper errno for various
	failure cases

getitimer01
	check that a correct call to getitimer() succeeds


getitimer02
	check that a getitimer() call fails as expected
	with an incorrect second argument.

getitimer03
	check that a getitimer() call fails as expected
	with an incorrect first argument.

setitimer01
	check that a reasonable setitimer() call succeeds.


setitimer02
	check that a setitimer() call fails as expected
	with incorrect values.

setitimer03
	check that a setitimer() call fails as expected
	with incorrect values.

float_trigo
	increase CPUs workload - verify that results of some math functions are stable
	trigonometric (acos, asin, atan, atan2, cos, sin, tan),
	hyperbolic (cosh, sinh, tanh),

float_exp_log
	increase CPUs workload - verify that results of some math functions are stable
	exponential and logarithmic functions (exp, log, log10),
	Functions that manipulate floating-point numbers (modf, ldexp, frexp),
	Euclidean distance function (hypot),

float_bessel
	increase CPUs workload - verify that results of some math functions are stable
	Bessel (j0, j1, y0, y1),
	Computes the natural logarithm of the gamma function (lgamma),

fload_power
	increase CPUs workload - verify that results of some math functions are stable
	Computes sqrt, power, fmod

float_iperb
	increase CPUs workload - verify that results of some math functions are stable
pth_str01

	Creates a tree of threads

pth_str02

	Creates n threads

pth_str03

	Creates a tree of threads does calculations, and
	returns result to parent


asyncio02

	Write/close flushes data to the file.


fpathconf

	Basic test for fpathconf(2)

gethostid01

	Basic test for gethostid(2) 


pathconf01

	Basic test for pathconf(2) 

setpgrp01

	Basic test for the setpgrp(2) system call.  

setpgrp02  

	Testcase to check the basic functionality of the setpgrp(2) syscall.


ulimit01

	Basic test for the ulimit(2) system call. 

mmstress

	Performs General Stress with Race conditions

mmap1

	Test the LINUX memory manager. The program is aimed at
	stressing the memory manager by simultaneous map/unmap/read
	by light weight processes, the test is scheduled to run for
	a minimum of 24 hours.

mmap2

	Test the LINUX memory manager. The program is aimed at
	stressing the memory manager by repeated map/write/unmap of a
	of a large gb size file.

mmap3

	Test the LINUX memory manager. The program is aimed at
	stressing the memory manager by repeated map/write/unmap
	of file/memory of random size (maximum 1GB) this is done by
	multiple processes.

mmap001

	Tests mmapping a big file and writing it once 

mmap01  

	Verify that, mmap() succeeds when used to map a file where size of the
	file is not a multiple of the page size, the memory area beyond the end
	of the file to the end of the page is accessible. Also, verify that
	this area is all zeroed and the modifications done to this area are
	not written to the file.

mmap02  

	Call mmap() with prot parameter set to PROT_READ and with the file
	descriptor being open for read, to  map a file creating mapped memory
	with read access. The minimum file permissions should be 0444.

mmap03  

	Call mmap() to map a file creating a mapped region with execute access
	under the following conditions -
	- The prot parameter is set to PROT_EXE
	- The file descriptor is open for read
	- The file being mapped has execute permission bit set.
	- The minimum file permissions should be 0555.

	The call should succeed to map the file creating mapped memory with the
	required attributes.

mmap04  

	Call mmap() to map a file creating a mapped region with read/exec access
	under the following conditions -
	- The prot parameter is set to PROT_READ|PROT_EXEC
	- The file descriptor is open for read
	- The file being mapped has read and execute permission bit set.
	- The minimum file permissions should be 0555.

	The call should succeed to map the file creating mapped memory with the
	required attributes.


mmap05  

	Call mmap() to map a file creating mapped memory with no access under
	the following conditions -
	- The prot parameter is set to PROT_NONE
	- The file descriptor is open for read(any mode other than write)
	- The minimum file permissions should be 0444.

	The call should succeed to map the file creating mapped memory with the
	required attributes.

mmap06  

	Call mmap() to map a file creating a mapped region with read access
	under the following conditions -
	- The prot parameter is set to PROT_READ
	- The file descriptor is open for writing.

	The call should fail to map the file.


mmap07  

	Call mmap() to map a file creating a mapped region with read access
	under the following conditions -
	- The prot parameter is set to PROT_WRITE
	- The file descriptor is open for writing.
	- The flags parameter has MAP_PRIVATE set.

	The call should fail to map the file.

mmap08  

	Verify that mmap() fails to map a file creating a mapped region 
	when the file specified by file descriptor is not valid.


mremap01  

	Verify that, mremap() succeeds when used to expand the existing
	virtual memory mapped region to the requested size where the
	virtual memory area was previously mapped to a file using mmap().

mremap02  

	Verify that, 
	mremap() fails when used to expand the existing virtual memory mapped 
	region to the requested size, if the virtual memory area previously 
	mapped was not page aligned or invalid argument specified.

mremap03  

	Verify that, 
	mremap() fails when used to expand the existing virtual memory mapped 
	region to the requested size, if there already exists mappings that
	cover the whole address space requested or the old address specified was
	not mapped.

mremap04  

	Verify that, 
	mremap() fails when used to expand the existing virtual memory mapped 
	region to the requested size, if the memory area cannot be expanded at
	the current virtual address and MREMAP_MAYMOVE flag not set.

munmap01  

	Verify that, munmap call will succeed to unmap a mapped file or
	anonymous shared memory region from the calling process's address space
	and after successful completion of munmap, the unmapped region is no
	longer accessible.

munmap02  

	Verify that, munmap call will succeed to unmap a mapped file or
	anonymous shared memory region from the calling process's address space
	if the region specified by the address and the length is part or all of
	the mapped region.

munmap03  

	Verify that, munmap call will fail to unmap a mapped file or anonymous
	shared memory region from the calling process's address space if the
	address and the length of the region to be unmapped points outside the
	calling process's address space

brk01
	Test the basic functionality of brk.

sbrk01
	Basic test for the sbrk(2) system call.


mprotect01  

	Testcase to check the error conditions for mprotect(2)

mprotect02  

	Testcase to check the mprotect(2) system call.

mprotect03  

	Testcase to check the mprotect(2) system call.

msgctl01 
	create a message queue, then issue the IPC_STAT command
	and RMID commands to test the functionality


msgctl02 
	create a message queue, then issue the IPC_SET command
	to lower the msg_qbytes value.


msgctl03
	create a message queue, then issue the IPC_RMID command



msgctl04 
	test for EACCES, EFAULT and EINVAL errors using
	a variety of incorrect calls.


msgctl05 
	test for EPERM error



msgget01 
	create a message queue, write a message to it and
	read it back.


msgget02 
	test for EEXIST and ENOENT errors


msgget03 
	test for an ENOSPC error by using up all available
	message queues.

msgget04 
	test for an EACCES error by creating a message queue
	with no read or write permission and then attempting
	to access it with various permissions.

msgrcv01 
	test that msgrcv() receives the expected message

msgrcv02
	test for EACCES and EFAULT errors

msgrcv03
	test for EINVAL error

msgrcv04
	test for E2BIG and ENOMSG errors

msgrcv05
	test for EINTR error

msgrcv06
	test for EIDRM error

msgsnd01
	test that msgsnd() enqueues a message correctly

msgsnd02
	test for EACCES and EFAULT errors

msgsnd03
	test for EINVAL error

msgsnd04
	test for EAGAIN error

msgsnd05
	test for EINTR error


msgsnd06
	test for EIDRM error

link02

	Basic test for link(2) 

link03

	Multi links tests

link04

	Negative test cases for link(2)

link05

	Multi links (EMLINK) negative test 

readlink01  

	Verify that, readlink will succeed to read the contents of the symbolic
	link created the process.

readlink02

	Basic test for the readlink(2) system call 

readlink03  

	Verify that,
	1) readlink(2) returns -1 and sets errno to EACCES if search/write
	permission is denied in the directory where the symbolic link
	resides.
	2) readlink(2) returns -1 and sets errno to EINVAL if the buffer size
	is not positive.
	3) readlink(2) returns -1 and sets errno to EINVAL if the specified
	file is not a symbolic link file.
	4) readlink(2) returns -1 and sets errno to ENAMETOOLONG if the 
	pathname component of symbolic link is too long (ie, > PATH_MAX).
	5) readlink(2) returns -1 and sets errno to ENOENT if the component of
	symbolic link points to an empty string.

readlink04  

	Verify that, readlink call will succeed to read the contents of the
	symbolic link if invoked by non-root user who is not the owner of the
	symbolic link.


symlink01

	Test of various file function calls, such as rename or open, on a symbolic 
	link file. 

symlink02

	Basic test for the symlink(2) system call. 

symlink03  

	Verify that,
	1) symlink(2) returns -1 and sets errno to EACCES if search/write
	permission is denied in the directory where the symbolic link is
	being created.
	2) symlink(2) returns -1 and sets errno to EEXIST if the specified 
	symbolic link already exists.
	3) symlink(2) returns -1 and sets errno to EFAULT if the specified
	file or symbolic link points to invalid address.
	4) symlink(2) returns -1 and sets errno to ENAMETOOLONG if the 
	pathname component of symbolic link is too long (ie, > PATH_MAX).
	5) symlink(2) returns -1 and sets errno to ENOTDIR if the directory
	component in pathname of symbolic link is not a directory.
	6) symlink(2) returns -1 and sets errno to ENOENT if the component of
	symbolic link points to an empty string.

symlink04  

	Verify that, symlink will succeed to create a symbolic link of an existing
	object name path.


symlink05  

	Verify that, symlink will succeed to create a symbolic link of an
	non-existing object name path.


unlink05

	Basic test for the unlink(2) system call. 

unlink06

	Test for the unlink(2) system call of a FIFO. 

unlink07

	Tests for error handling for the unlink(2) system call. 

unlink08

	More tests for error handling for the unlink(2) system call.


linktest

	Regression test for max links per file

rename01  

	This test will verify the rename(2) syscall basic functionality.
	Verify rename() works when the "new" file or directory does not exist.

rename02

	Basic test for the rename(2) system call

rename03  

	This test will verify that rename(2) functions correctly
	when the "new" file or directory exists

rename04  

	This test will verify that rename(2) failed when newpath is 
	a non-empty directory and return EEXIST or ENOTEMPTY

rename05  

	This test will verify that rename(2) fails with EISDIR

rename06  

	This test will verify that rename(2) failed in EINVAL

rename07  

	This test will verify that rename(2) failed in ENOTDIR

rename08  

	This test will verify that rename(2) syscall failed in EFAULT

rename09  

	check rename() fails with EACCES

rename10  

	This test will verify that rename(2) syscall fails with ENAMETOOLONG
	and ENOENT

rename11  

	This test will verify that rename(2) failed in EBUSY

rename12  

	check rename() fails with EPERM

rename13  

	Verify rename() return successfully and performs no other action
	when "old" file and "new" file link to the same file.

rmdir01  

	This test will verify that rmdir(2) syscall basic functionality.
	verify rmdir(2) returns a value of 0 and the directory being
	removed 

rmdir02  

	This test will verify that rmdir(2) fail in 
	1. ENOTEMPTY
	2. EBUSY
	3. ENAMETOOLONG
	4. ENOENT
	5. ENOTDIR
	6. EFAULT
	7. EFAULT

rmdir03  

	check rmdir() fails with EPERM or EACCES

rmdir04

	Basic test for the rmdir(2) system call 

rmdir05

	Verify that rmdir(2) returns a value of -1 and sets errno to indicate the error.



mkdir01

	Basic errno test for mkdir(2) 

mkdir02  

	This test will verify that new directory created
	by mkdir(2) inherits the group ID from the parent
	directory and S_ISGID bit, if the S_ISGID bit is set
	in the parent directory.

mkdir03  

	Check mkdir() with various error conditions that should produce
	EFAULT, ENAMETOOLONG, EEXIST, ENOENT and ENOTDIR

mkdir04  

	Attempt to create a directory in a directory having no permissions. 

mkdir05  

	This test will verify the mkdir(2) syscall basic functionality

mkdir08

	Basic test for mkdir(2)


mknod01

	Basic test for mknod(2) 

mknod02  

	Verify that mknod(2) succeeds when used to create a filesystem 
	node with set group-ID bit set on a directory without set group-ID bit set.
	The node created should have set group-ID bit set and its gid should be 
	equal to that of its parent directory.

mknod03  

	Verify that mknod(2) succeeds when used to create a filesystem 
	node with set group-ID bit set on a directory with set group-ID bit set.
	The node created should have set group-ID bit set and its gid should be 
	equal to the effective gid of the process.

mknod04  

	Verify that mknod(2) succeeds when used to create a filesystem 
	node on a directory with set group-ID bit set.
	The node created should not have group-ID bit set and its gid should be 
	equal to the effective gid of the process.

mknod05  

	Verify that mknod(2) succeeds when used by root to create a filesystem 
	node with set group-ID bit set on a directory with set group-ID bit set.
	The node created should have set group-ID bit set and its gid should be 
	equal to that of its parent directory.


mknod06  

	Verify that,
	1) mknod(2) returns -1 and sets errno to EEXIST if specified path
	already exists.
	2) mknod(2) returns -1 and sets errno to EFAULT if pathname points
	outside user's accessible address space.
	3) mknod(2) returns -1 and sets errno to ENOENT if the directory 
	component in pathname does not exist.
	4) mknod(2) returns -1 and sets errno to ENAMETOOLONG if the pathname
	component was too long.
	5) mknod(2) returns -1 and sets errno to ENOTDIR if the directory
	component in pathname is not a directory.

mknod07  

	Verify that,
	1) mknod(2) returns -1 and sets errno to EPERM if the process id of
	the caller is not super-user.
	2) mknod(2) returns -1 and sets errno to EACCES if parent directory
	does not allow  write  permission  to  the process.

mknod08  

	Verify that mknod(2) succeeds when used to create a filesystem 
	node on a directory without set group-ID bit set. The node created
	should not have set group-ID bit set and its gid should be equal to that
	of its parent directory.




access01

	Basic test for access(2) using F_OK, R_OK, W_OK, and X_OK  arguments.

access02  

	Verify that access() succeeds to check the read/write/execute permissions
	on a file if the mode argument passed was R_OK/W_OK/X_OK.

	Also verify that, access() succeeds to test the accessibility of the file
	referred to by symbolic link if the pathname points to a symbolic link.

access03

	EFAULT error testing for access(2).

access04  

	Verify that,
	1. access() fails with -1 return value and sets errno to EACCES
	if the permission bits of the file mode do not permit the
	requested (Read/Write/Execute) access.
	2. access() fails with -1 return value and sets errno to EINVAL
	if the specified access mode argument is invalid.
	3. access() fails with -1 return value and sets errno to EFAULT
	if the pathname points outside allocate address space for the
	process.
	4. access() fails with -1 return value and sets errno to ENOENT
	if the specified file doesn't exist (or pathname is NULL).
	5. access() fails with -1 return value and sets errno to ENAMETOOLONG
	if the pathname size is > PATH_MAX characters.

access05  

	Verify that access() succeeds to check the existence of a file if
	search access is permitted on the pathname of the specified file.

access06

	EFAULT error testing for access(2).

chroot01  

	Testcase to check the whether chroot sets errno to EPERM.

chroot02  

	Test functionality of chroot(2)

chroot03  

	Testcase to test whether chroot(2) sets errno correctly.

pipeio

	This tool can be used to beat on system or named pipes.
	See the help() function below for user information.

pipe01  

	Testcase to check the basic functionality of the pipe(2) syscall:
	Check that both ends of the pipe (both file descriptors) are
	available to a process opening the pipe.

pipe05  

	Check what happens when pipe is passed a bad file descriptor.

pipe06  

	Check what happens when the system runs out of pipes.

pipe08  

	Check that a SIGPIPE signal is generated when a write is
	attempted on an empty pipe.

pipe09  

	Check that two processes can use the same pipe at the same time.

pipe10  

	Check that parent can open a pipe and have a child read from it

pipe11  

	Check if many children can read what is written to a pipe by the
	parent.


sem01

	Creates a semaphore and two processes.  The processes
	each go through a loop where they semdown, delay for a
	random amount of time, and semup, so they will almost
	always be fighting for control of the semaphore.

sem02
	The application creates several threads using pthread_create().
	One thread performs a semop() with the SEM_UNDO flag set. The
	change in semaphore value performed by that semop should be
	"undone" only when the last pthread exits.


semctl01  

	test the 10 possible semctl() commands

semctl02  

	test for EACCES error

semctl03  

	test for EINVAL and EFAULT errors

semctl04 

	test for EPERM error


semctl05

	test for ERANGE error

semget01

	test that semget() correctly creates a semaphore set

semget02 

	test for EACCES and EEXIST errors

semget03 

	test for ENOENT error

semget05 

	test for ENOSPC error

semget06

	test for EINVAL error

semop01 

	test that semop() basic functionality is correct

semop02

	test for E2BIG, EACCES, EFAULT and EINVAL errors

semop03

	test for EFBIG error

semop04

	test for EAGAIN error

semop05

	test for EINTR and EIDRM errors



msgctl01 
	create a message queue, then issue the IPC_STAT command
	and RMID commands to test the functionality


msgctl02 
	create a message queue, then issue the IPC_SET command
	to lower the msg_qbytes value.


msgctl03
	create a message queue, then issue the IPC_RMID command



msgctl04 
	test for EACCES, EFAULT and EINVAL errors using
	a variety of incorrect calls.


msgctl05 
	test for EPERM error



msgget01 
	create a message queue, write a message to it and
	read it back.


msgget02 
	test for EEXIST and ENOENT errors


msgget03 
	test for an ENOSPC error by using up all available
	message queues.

msgget04 
	test for an EACCES error by creating a message queue
	with no read or write permission and then attempting
	to access it with various permissions.

msgrcv01 
	test that msgrcv() receives the expected message

msgrcv02
	test for EACCES and EFAULT errors

msgrcv03
	test for EINVAL error

msgrcv04
	test for E2BIG and ENOMSG errors

msgrcv05
	test for EINTR error

msgrcv06
	test for EIDRM error

msgsnd01
	test that msgsnd() enqueues a message correctly

msgsnd02
	test for EACCES and EFAULT errors

msgsnd03
	test for EINVAL error

msgsnd04
	test for EAGAIN error

msgsnd05
	test for EINTR error


msgsnd06
	test for EIDRM error

shmat01
	test that shmat() works correctly

shmat02
	check for EINVAL and EACCES errors


shmat03
	test for EACCES error


shmctl01
	test the IPC_STAT, IPC_SET and IPC_RMID commands as
	they are used with shmctl()


shmctl02
	check for EACCES, EFAULT and EINVAL errors


shmctl03
	check for EACCES, and EPERM errors


shmdt01
	check that shared memory is detached correctly


shmdt02
	check for EINVAL error


shmget01
	test that shmget() correctly creates a shared memory segment


shmget02
	check for ENOENT, EEXIST and EINVAL errors


shmget03
	test for ENOSPC error


shmget04
	test for EACCES error


shmget05
	test for EACCES error

openfile

	Creates files and opens simultaneously

open01  

	Open a file with oflag = O_CREAT set, does it set the sticky bit off?

	Open "/tmp" with O_DIRECTORY, does it set the S_IFDIR bit on?

open02  

	Test if open without O_CREAT returns -1 if a file does not exist.

open03

	Basic test for open(2)  

open04  

	Testcase to check that open(2) sets EMFILE if a process opens files
	more than its descriptor size

open05  

	Testcase to check open(2) sets errno to EACCES correctly.

open06  

	Testcase to check open(2) sets errno to ENXIO correctly.

open07  

	Test the open(2) system call to ensure that it sets ELOOP correctly.

open08  

	Check for the following errors:
	1.	EEXIST
	2.	EISDIR
	3.	ENOTDIR
	4.	ENAMETOOLONG
	5.	EFAULT
	6.	ETXTBSY


openfile

	Creates files and opens simultaneously


chdir01  

	Check proper operation of chdir(): tests whether the
	system call can it change the current, working directory, and find a
	file there? Will it fail on a non-directory entry ?

chdir02	 	

	Basic test for chdir(2).

chdir03  

	Testcase for testing that chdir(2) sets EACCES errno

chdir04  

	Testcase to test whether chdir(2) sets errno correctly.


chmod01  

	Verify that, chmod(2) succeeds when used to change the mode permissions
	of a file. 

chmod02

	Basic test for chmod(2).

chmod03  

	Verify that, chmod(2) will succeed to change the mode of a file
	and set the sticky bit on it if invoked by non-root (uid != 0)
	process with the following constraints,
	- the process is the owner of the file.
	- the effective group ID or one of the supplementary group ID's of the
	process is equal to the group ID of the file.

chmod04  

	Verify that, chmod(2) will succeed to change the mode of a directory
	and set the sticky bit on it if invoked by non-root (uid != 0) process
	with the following constraints,
	- the process is the owner of the directory.
	- the effective group ID or one of the supplementary group ID's of the
	process is equal to the group ID of the directory.

chmod05  

	Verify that, chmod(2) will succeed to change the mode of a directory
	but fails to set the setgid bit on it if invoked by non-root (uid != 0)
	process with the following constraints,
	- the process is the owner of the directory.
	- the effective group ID or one of the supplementary group ID's of the
	process is not equal to the group ID of the directory.

chmod06  

	Verify that,
	1) chmod(2) returns -1 and sets errno to EPERM if the effective user id
	of process does not match the owner of the file and the process is
	not super user.
	2) chmod(2) returns -1 and sets errno to EACCES if search permission is
	denied on a component of the path prefix.
	3) chmod(2) returns -1 and sets errno to EFAULT if pathname points
	outside user's accessible address space.
	4) chmod(2) returns -1 and sets errno to ENAMETOOLONG if the pathname
	component is too long.
	5) chmod(2) returns -1 and sets errno to ENOTDIR if the directory
	component in pathname is not a directory.
	6) chmod(2) returns -1 and sets errno to ENOENT if the specified file
	does not exists.

chmod07  

	Verify that, chmod(2) will succeed to change the mode of a file/directory
	and sets the sticky bit on it if invoked by root (uid = 0) process with
	the following constraints,
	- the process is not the owner of the file/directory.
	- the effective group ID or one of the supplementary group ID's of the
	process is equal to the group ID of the file/directory.


chown01

	Basic test for chown(2).

chown02  

	Verify that, when chown(2) invoked by super-user to change the owner and
	group of a file specified by path to any numeric owner(uid)/group(gid)
	values,
	- clears setuid and setgid bits set on an executable file.
	- preserves setgid bit set on a non-group-executable file.

chown03  

	Verify that, chown(2) succeeds to change the group of a file specified
	by path when called by non-root user with the following constraints,
	- euid of the process is equal to the owner of the file.	 
	- the intended gid is either egid, or one of the supplementary gids
	of the process.
	Also, verify that chown() clears the setuid/setgid bits set on the file.

chown04  

	Verify that,
	1) chown(2) returns -1 and sets errno to EPERM if the effective user id
	of process does not match the owner of the file and the process is
	not super user.
	2) chown(2) returns -1 and sets errno to EACCES if search permission is
	denied on a component of the path prefix.
	3) chown(2) returns -1 and sets errno to EFAULT if pathname points
	outside user's accessible address space.
	4) chown(2) returns -1 and sets errno to ENAMETOOLONG if the pathname
	component is too long.
	5) chown(2) returns -1 and sets errno to ENOTDIR if the directory
	component in pathname is not a directory.
	6) chown(2) returns -1 and sets errno to ENOENT if the specified file
	does not exists.

chown05  

	Verify that, chown(2) succeeds to change the owner and group of a file
	specified by path to any numeric owner(uid)/group(gid) values when invoked 
	by super-user.


close01  

	Test that closing a regular file and a pipe works correctly

close02  

	Check that an invalid file descriptor returns EBADF

close08

	Basic test for close(2).


fchdir01  

	create a directory and cd into it.

fchdir02  

	try to cd into a bad directory (bad fd).


fchmod01

	Basic test for Fchmod(2).

fchmod02  

	Verify that, fchmod(2) will succeed to change the mode of a file/directory
	set the sticky bit on it if invoked by root (uid = 0) process with
	the following constraints,
	- the process is not the owner of the file/directory.
	- the effective group ID or one of the supplementary group ID's of the
	process is equal to the group ID of the file/directory.

fchmod03  

	Verify that, fchmod(2) will succeed to change the mode of a file
	and set the sticky bit on it if invoked by non-root (uid != 0)
	process with the following constraints,
	- the process is the owner of the file.
	- the effective group ID or one of the supplementary group ID's of the
	process is equal to the group ID of the file.

fchmod04  

	Verify that, fchmod(2) will succeed to change the mode of a directory
	and set the sticky bit on it if invoked by non-root (uid != 0) process
	with the following constraints,
	- the process is the owner of the directory.
	- the effective group ID or one of the supplementary group ID's of the
	process is equal to the group ID of the directory.

fchmod05  

	Verify that, fchmod(2) will succeed to change the mode of a directory
	but fails to set the setgid bit on it if invoked by non-root (uid != 0)
	process with the following constraints,
	- the process is the owner of the directory.
	- the effective group ID or one of the supplementary group ID's of the
	process is not equal to the group ID of the directory.

fchmod06  

	Verify that,
	1) fchmod(2) returns -1 and sets errno to EPERM if the effective user id
	of process does not match the owner of the file and the process is
	not super user.
	2) fchmod(2) returns -1 and sets errno to EBADF if the file descriptor
	of the specified file is not valid.

fchmod07  

	Verify that, fchmod(2) succeeds when used to change the mode permissions
	of a file specified by file descriptor. 


fchown01

	Basic test for fchown(2).

fchown02  

	Verify that, when fchown(2) invoked by super-user to change the owner and
	group of a file specified by file descriptor to any numeric 
	owner(uid)/group(gid) values,
	- clears setuid and setgid bits set on an executable file.
	- preserves setgid bit set on a non-group-executable file.

fchown03  

	Verify that, fchown(2) succeeds to change the group of a file specified
	by path when called by non-root user with the following constraints,
	- euid of the process is equal to the owner of the file.	 
	- the intended gid is either egid, or one of the supplementary gids
	of the process.
	Also, verify that fchown() clears the setuid/setgid bits set on the file.

fchown04  

	Verify that,
	1) fchown(2) returns -1 and sets errno to EPERM if the effective user id
	of process does not match the owner of the file and the process is
	not super user.
	2) fchown(2) returns -1 and sets errno to EBADF if the file descriptor
	of the specified file is not valid.

fchown05  

	Verify that, fchown(2) succeeds to change the owner and group of a file
	specified by file descriptor to any numeric owner(uid)/group(gid) values 
	when invoked by super-user.

lchown01  

	Verify that, lchown(2) succeeds to change the owner and group of a file
	specified by path to any numeric owner(uid)/group(gid) values when invoked 
	by super-user.


lchown02  

	Verify that,
	1) lchown(2) returns -1 and sets errno to EPERM if the effective user id
	of process does not match the owner of the file and the process is
	not super user.
	2) lchown(2) returns -1 and sets errno to EACCES if search permission is
	denied on a component of the path prefix.
	3) lchown(2) returns -1 and sets errno to EFAULT if pathname points
	outside user's accessible address space.
	4) lchown(2) returns -1 and sets errno to ENAMETOOLONG if the pathname
	component is too long.
	5) lchown(2) returns -1 and sets errno to ENOTDIR if the directory
	component in pathname is not a directory.
	6) lchown(2) returns -1 and sets errno to ENOENT if the specified file
	does not exists.


creat01  

	Testcase to check the basic functionality of the creat(2) system call.

creat03  

	Testcase to check whether the sticky bit cleared.

creat04  

	Testcase to check creat(2) fails with EACCES

creat05  

	Testcase to check that creat(2) system call returns EMFILE.

creat06  

	Testcase to check creat(2) sets the following errnos correctly:
	1.	EISDIR
	2.	ENAMETOOLONG
	3.	ENOENT
	4.	ENOTDIR
	5.	EFAULT
	6.	EACCES

creat07  

	Testcase to check creat(2) sets the following errnos correctly:
	1.	ETXTBSY

creat09

	Basic test for creat(2) using 0700 argument.

truncate01  

	Verify that, truncate(2) succeeds to truncate a file to a specified
	length.


truncate02  

	Verify that, truncate(2) succeeds to truncate a file to a certain length,
	but the attempt to read past the truncated length will fail.  


truncate03  

	Verify that,
	1) truncate(2) returns -1 and sets errno to EACCES if search/write
	permission denied for the process on the component of the path prefix
		or named file.
	2) truncate(2) returns -1 and sets errno to ENOTDIR if the component of
	the path prefix is not a directory.
	3) truncate(2) returns -1 and sets errno to EFAULT if pathname points
	outside user's accessible address space.
	4) truncate(2) returns -1 and sets errno to ENAMETOOLONG if the component
	of a pathname exceeded 255 characters or entire pathname exceeds 1023
	characters.
	5) truncate(2) returns -1 and sets errno to ENOENT if the named file
	does not exist.

ftruncate01  

	Verify that, ftruncate(2) succeeds to truncate a file to a specified
	length if the file indicated by file descriptor opened for writing.

ftruncate02  

	Verify that, ftruncate(2) succeeds to truncate a file to a certain length,
	but the attempt to read past the truncated length will fail.  

ftruncate03  

	Verify that,
	1) ftruncate(2) returns -1 and sets errno to EINVAL if the specified
	truncate length is less than 0.
	2) ftruncate(2) returns -1 and sets errno to EBADF if the file descriptor
	of the specified file is not valid.

vhangup01  

	Check the return value, and errno of vhangup(2)
	when a non-root user calls vhangup().

vhangup02  

	To test the basic functionality of vhangup(2)
growfiles

	This program will grow a list of files.
	Each file will grow by grow_incr before the same
	file grows twice.  Each file is open and closed before next file is opened.

pipe01  

	Testcase to check the basic functionality of the pipe(2) syscall:
	Check that both ends of the pipe (both file descriptors) are
	available to a process opening the pipe.

pipe05  

	Check what happens when pipe is passed a bad file descriptor.

pipe06  

	Check what happens when the system runs out of pipes.

pipe08  

	Check that a SIGPIPE signal is generated when a write is
	attempted on an empty pipe.

pipe09  

	Check that two processes can use the same pipe at the same time.

pipe10  

	Check that parent can open a pipe and have a child read from it

pipe11  

	Check if many children can read what is written to a pipe by the
	parent.

pipeio

	This tool can be used to beat on system or named pipes.
	See the help() function below for user information.

	/ipc_stress/message_queue_test_01.c
	/ipc_stress/pipe_test_01.c
	/ipc_stress/semaphore_test_01.c
	/ipc_stress/single_test_01.c

proc01
	Recursively reads all files within /proc filesystem.

lftest
	The purpose of this test is to verify the file size limitations of a filesystem.
	It writes one buffer at a time and lseeks from the beginning of the file to the
	end of the last write position.  The intent is to test lseek64.


llseek01  

	Verify that, llseek() call succeeds to set the file pointer position 
	to an offset larger than file size. Also, verify that any attempt
	to write to this location fails.

llseek02  

	Verify that,
	1. llseek() returns -1 and sets errno to EINVAL, if the 'Whence' argument
	is not a proper value.
	2. llseek() returns -1 and sets errno to EBADF, if the file handle of
	the specified file is not valid.

lseek01

	Basic test for lseek(2) 

lseek02

	Negative test for lseek(2) 

lseek03

	Negative test for lseek(2) whence

lseek04

	Negative test for lseek(2) of a fifo 

lseek05

	Negative test for lseek(2) of a pipe

lseek06  

	Verify that, lseek() call succeeds to set the file pointer position 
	to less  than  or equal to the file size, when a file is opened for
	read or write.

lseek07  

	Verify that, lseek() call succeeds to set the file pointer position
	to more than the file size, when a file is opened for reading/writing.

lseek08  

	Verify that, lseek() call succeeds to set the file pointer position 
	to the end of the file when 'whence' value set to SEEK_END and any
	attempts to read from that position should fail.

lseek09  

	Verify that, lseek() call succeeds to set the file pointer position 
	to the current specified location, when 'whence' value is set to
	SEEK_CUR and the data read from the specified location should match
	the expected data.

lseek10  

	Verify that,
	1. lseek() returns -1 and sets errno to ESPIPE, if the file handle of
	the specified file is associated with a pipe, socket, or  FIFO.	
	2. lseek() returns -1 and sets errno to EINVAL, if the 'Whence' argument
	is not a proper value.
	3. lseek() returns -1 and sets errno to EBADF, if the file handle of
	the specified file is not valid.

rwtest

	A wrapper for doio and iogen.

doio 
	a general purpose io initiator with system call and
	write logging.  See doio.h for the structure which defines
	what doio requests should look like.

	Currently doio can handle read,write,reada,writea,ssread,
	sswrite, and many varieties of listio requests.
	For disk io, if the O_SSD flag is set doio will allocate
	the appropriate amount of ssd and do the transfer - thus, doio
	can handle all of the primitive types of file io.

iogen 
	A tool for generating file/sds io for a doio process

pread01  

	Verify the functionality of pread() by writing known data using pwrite()
	to the file at various specified offsets and later read from the file from
	various specified offsets, comparing the data read against the data 
	written.

pread02  

	Verify that,
	1) pread() fails when attempted to read from an unnamed pipe.
	2) pread() fails if the specified offset position was invalid.


pwrite01  

	Verify the functionality of pwrite() by writing known data using pwrite()
	to the file at various specified offsets and later read from the file from
	various specified offsets, comparing the data written against the data
	read using read().

pwrite02  

	Verify that,
	1) pwrite() fails when attempted to write to an unnamed pipe.
	2) pwrite() fails if the specified offset position was invalid.


read01

	Basic test for the read(2) system call

read02  

	test 1: Does read return -1 if file descriptor is not valid, check for EBADF

	test 2: Check if read sets EISDIR, if the fd refers to a directory

	test 3: Check if read sets EFAULT, if buf is -1.

read03  

	Testcase to check that read() sets errno to EAGAIN

read04  

	Testcase to check if read returns the number of bytes read correctly.


readv01  

	Testcase to check the basic functionality of the readv(2) system call.

readv02  

	Testcase to check the error conditions of the readv(2) system call.

write01

	Basic test for write(2) system call.

write02  

	Basic functionality test: does the return from write match the count
	of the number of bytes written.


write03  

	Testcase to check that write(2) doesn't corrupt a file when it fails

write04  

	Testcase to check that write() sets errno to EAGAIN

write05  

	Check the return value, and errnos of write(2)
	- when the file descriptor is invalid - EBADF
	- when the buf parameter is invalid - EFAULT
	- on an attempt to write to a pipe that is not open for reading - EPIPE


writev01  

	Testcase to check the basic functionality of writev(2) system call.


writev02  

	In these testcases, writev() is called with partially valid data 
	to be written in a sparse file.


writev03  

	The testcases are written calling writev() with partially valid data
	to overwrite the contents, to write in the beginning and to write in
	the end of the file.

writev04  

	The testcases are written calling writev() with partially valid data
	to overwrite the contents, to write in the beginning and to write in
	the end of the file. This is same as writev03, but the length of
	buffer used here is 8192 bytes.

writev05  

	These testcases are written to test writev() on sparse files. This
	is same as writev02. But the initial write() with valid data is
	done at the beginning of the file.

disktest

	Does repeated accesses to a filespec and optionally writes to, reads from,
	and  verifies  the  data.  By default, disktest makes assumptions about
	the running environment which allows for a quick start of IO generation.
	However, Disktest has  a  large  number  of command line options which can
	be used to adapt the test for a variety of uses including data integrity,
	medium integrity, performance, and  simple application simulation.




getdents01
	get a directory entry

getdents02
	check that we get a failure with a bad file descriptor


getdents03
	check for an EINVAL error


getdents04
	check for an ENOTDIR error

getdents05
	check that we get a failure with a bad dirp address.
process_stress
	Spawn creates a tree
	of processes with Dval depth and Bval breadth.  Each parent will spawn
	Bval children.  Each child will store information about themselves
	in shared memory.  The leaf nodes will communicate the existence
	of one another through message queues, once each leaf node has
	received communication from all of her siblings she will reduce
	the semaphore count and exit.  Meanwhile all parents are waiting
	to hear from their children through the use of semaphores.  When
	the semaphore count reaches zero then the parent knows all the
	children have talked to one another.  Locking of the connter semaphore
	is provided by the use of another (binary) semaphore.




sched_stress
	Exports required environment variables and runs sched_driver
sched_driver
	This program uses system calls to change the 
	priorities of the throughput measurement testcases.  
	When real-time is in effect, priorities 50 through 64
	are used.  (MAX_PRI and MIN_PRI)  When user-time     
	(normal) is in effect, 0-14 (corresponding to nice()  
	calls) is used.  The driver only keeps track of      
	values from 50 to 64, and the testcases will scale   
	them down to 0 to 14 when needed, to change the      
	priority of a user-time process.                       

time-schedule
	This programme will determine the context switch 
	(scheduling) overhead on a system. It takes into 
	account SMP machines. True context switches are 
	measured.
trace_sched
	This utility spawns N tasks, each task sets its priority 
	by making a system call to the scheduler. The thread 
	function reads the priority that the scheduler sets for 
	this task and also reads from /proc the processor this 
	task last executed on the information that is gathered 
	by the thread function may be in real-time. Its only an 
	approximation.         

sched_getscheduler01  

	Testcase to check sched_getscheduler() returns correct return value 

sched_getscheduler02  

	To check for the errno ESRCH


sched_setscheduler01  

	Testcase to test whether sched_setscheduler(2) sets the errnos
	correctly.

sched_setscheduler02  

	Testcase to test whether sched_setscheduler(2) sets the errnos
	correctly.


sched_yield01  

	Testcase to check that sched_yield returns correct values.


nice01  

	Verify that root can provide a negative value  to nice()
	and hence root can decrease the nice value of the process
	using nice() system call

nice02  

	Verify that any user can successfully increase the nice value of
	the process by passing a higher increment value (> max. applicable limits)
	to nice() system call.

nice03  

	Verify that any user can successfully increase the nice value of
	the process by passing an increment value (< max. applicable limits) to 
	nice() system call.

nice04  

	Verify that, nice(2) fails when, a non-root user attempts to increase
	the priority of a process by specifying a negative increment value.

nice05

	Basic test for nice(2) 


poll01  

	Verify that valid open file descriptor must be provided to poll() to
	succeed.

select01

	Basic test for the select(2) system call to a fd of regular file with no I/O 
	and small timeout 

select02

	Basic test for the select(2) system call to fd of system pipe with no I/O 
	and small timeout 

select03

	Basic test for the select(2) system call to fd of a named-pipe (FIFO) 

select04  

	Verify that select(2) returns immediately (does not block) if the
	timeout value is zero.

select05  

	Verify that select(2) fails when one or more of the file descriptor sets
	specify a file descriptor which is not valid.

select06  

	Verify that select(2) fails when a signal is delivered before any of the
	selected events occur and before the timeout interval expires.

select07  

	Verify that select(2) fails when an invalid timeout interval is specified.

select08  

	Verify the functionality of select(2) by passing non-null writefds
	which points to a regular file, pipes or FIFO's.

select09  

	Verify the functionality of select(2) by passing non-null readfds
	which points to a regular file, pipes or FIFO's.

select10 

	Verify that a successful call to select() shall return the desired 
	number of modified descriptors for which bits are set in the bit masks, 
	where descriptors points to a regular file, pipes or FIFO's.
sem01

	Creates a semaphore and two processes.  The processes
	each go through a loop where they semdown, delay for a
	random amount of time, and semup, so they will almost
	always be fighting for control of the semaphore.

sem02
	The application creates several threads using pthread_create().
	One thread performs a semop() with the SEM_UNDO flag set. The
	change in semaphore value performed by that semop should be
	"undone" only when the last pthread exits.


semctl01  

	test the 10 possible semctl() commands

semctl02  

	test for EACCES error

semctl03  

	test for EINVAL and EFAULT errors

semctl04 

	test for EPERM error


semctl05

	test for ERANGE error

semget01

	test that semget() correctly creates a semaphore set

semget02 

	test for EACCES and EEXIST errors

semget03 

	test for ENOENT error

semget05 

	test for ENOSPC error

semget06

	test for EINVAL error

semop01 

	test that semop() basic functionality is correct

semop02

	test for E2BIG, EACCES, EFAULT and EINVAL errors

semop03

	test for EFBIG error

semop04

	test for EAGAIN error

semop05

	test for EINTR and EIDRM errors


shmat01
	test that shmat() works correctly

shmat02
	check for EINVAL and EACCES errors


shmat03
	test for EACCES error


shmctl01
	test the IPC_STAT, IPC_SET and IPC_RMID commands as
	they are used with shmctl()


shmctl02
	check for EACCES, EFAULT and EINVAL errors


shmctl03
	check for EACCES, and EPERM errors


shmdt01
	check that shared memory is detached correctly


shmdt02
	check for EINVAL error


shmget01
	test that shmget() correctly creates a shared memory segment


shmget02
	check for ENOENT, EEXIST and EINVAL errors


shmget03
	test for ENOSPC error


shmget04
	test for EACCES error


shmget05
	test for EACCES error
shmat1

	Test the LINUX memory manager. The program is aimed at
	stressing the memory manager by repeated shmat/write/read/
	shmatd of file/memory of random size (maximum 1000 * 4096)
	done by multiple processes.

shm_test

	This program is designed to stress the Memory management sub -
	system of Linux. This program will spawn multiple pairs of
	reader and writer threads. One thread will create the shared
	segment of random size and write to this memory, the other
	pair will read from this memory.

sigaction01  

	Test some features of sigaction (see below for more details)


sigaction02  

	Testcase to check the basic errnos set by the sigaction(2) syscall.


sigaltstack01  

	Send a signal using the main stack. While executing the signal handler
	compare a variable's address lying on the main stack with the stack
	boundaries returned by sigaltstack().


sigaltstack02  

	Verify that,
	1. sigaltstack() fails and sets errno to EINVAL when "ss_flags" field
	pointed to by 'ss' contains invalid flags.
	2. sigaltstack() fails and sets errno to ENOMEM when the size of alternate
	stack area is less than MINSIGSTKSZ.

sighold02

	Basic test for the sighold02(2) system call. 


signal01
	set the signal handler to our own function


signal02 
	Test that we get an error using illegal signals

signal03

	Boundary value and other invalid value checking of signal setup and signal 
	sending. 


signal04 
	restore signals to default behavior


signal05 
	set signals to be ignored


sigprocmask01  

	Verify that sigprocmask() succeeds to examine and change the calling
	process's signal mask. 
	Also, verify that sigpending() succeeds to store signal mask that are
	blocked from delivery and pending for the calling process.

sigrelse01

	Basic test for the sigrelse(2) system call. 

sigsuspend01  

	Verify that sigsuspend() succeeds to change process's current signal
	mask with the specified signal mask and suspends the process execution
	until the delivery of a signal.
kill01  

	Test case to check the basic functionality of kill().

kill02

	Sending a signal to processes with the same process group ID

kill03  

	Test case to check that kill fails when given an invalid signal.

kill04  

	Test case to check that kill() fails when passed a non-existent pid.

kill05  

	Test case to check that kill() fails when passed a pid owned by another
	user.

kill06  

	Test case to check the basic functionality of kill() when killing an
	entire process group with a negative pid.

kill07  

	Test case to check that SIGKILL can not be caught.

kill08  

	Test case to check the basic functionality of kill() when kill an
	entire process group.

kill09
	Basic test for kill(2)

kill10
	Signal flooding test.


mtest01
        mallocs memory <chunksize> at a time until malloc fails.
mallocstress

	This program is designed to stress the VMM by doing repeated  */
	mallocs and frees, with out using the swap space. This is     */
	achieved by spawning N threads with repeatedly malloc and free*/
	a memory of size M. The stress can be increased by increasing */
	the number of repetitions over the default number using the   */
	-l [num] option.

clisrv

	Sender: Read contents of data file. Write each line to socket, then
	read line back from socket and write to standard output.      
	Receiver: Read a stream socket one line at a time and write each line
	back to the sender.                                       
	Usage:       pthcli [port number]                 
			    

socket01  

	Verify that socket() returns the proper errno for various failure cases


socketpair01  

	Verify that socketpair() returns the proper errno for various failure cases


sockioctl01  

	Verify that ioctl() on sockets returns the proper errno for various
	failure cases

connect01  

	Verify that connect() returns the proper errno for various failure cases

getpeername01

	Verify that getpeername() returns the proper errno for various failure cases


getsockname01      

	Verify that getsockname() returns the proper errno for various failure cases

getsockopt01       

	Verify that getsockopt() returns the proper errno for various failure cases

listen01

	Verify that listen() returns the proper errno for various failure cases

accept01

	Verify that accept() returns the proper errno for various failure cases

bind01

	Verify that bind() returns the proper errno for various failure cases


recv01  

	Verify that recv() returns the proper errno for various failure cases


recvfrom01  

	Verify that recvfrom() returns the proper errno for various failure cases


recvmsg01  

	Verify that recvmsg() returns the proper errno for various failure cases

send01

	Verify that send() returns the proper errno for various failure cases

sendmsg01

	Verify that sendmsg() returns the proper errno for various failure cases
sendto01

	Verify that sendto() returns the proper errno for various failure cases

setsockopt01  

	Verify that setsockopt() returns the proper errno for various failure cases


fstat01

	Basic test for fstat(2)

fstat02  

	Verify that, fstat(2) succeeds to get the status of a file and fills
	the stat structure elements though file pointed to by file descriptor
	not opened for reading.

fstat03  

	Verify that, fstat(2) returns -1 and sets errno to EBADF if the file 
	pointed to by file descriptor is not valid.

fstat04

	Verify that, fstat(2) succeeds to get the status of a file pointed by
	file descriptor and fills the stat structure elements.


fstatfs01

	Basic test for fstatfs(2)

fstatfs02  

	Testcase to check fstatfs() sets errno correctly.

lstat01  

	Verify that, lstat(2) succeeds to get the status of a file pointed to by
	symlink and fills the stat structure elements.

lstat02

	Basic test for lstat(2) 

lstat03  

	Verify that,
	1) lstat(2) returns -1 and sets errno to EACCES if search permission is
	denied on a component of the path prefix.
	2) lstat(2) returns -1 and sets errno to ENOENT if the specified file
	does not exists or empty string.
	3) lstat(2) returns -1 and sets errno to EFAULT if pathname points
	outside user's accessible address space.
	4) lstat(2) returns -1 and sets errno to ENAMETOOLONG if the pathname
	component is too long.
	5) lstat(2) returns -1 and sets errno to ENOTDIR if the directory
	component in pathname is not a directory.

stat01  

	Verify that, stat(2) succeeds to get the status of a file and fills the
	stat structure elements.

stat02  

	Verify that, stat(2) succeeds to get the status of a file and fills the
	stat structure elements though process doesn't have read access to the
	file.


stat03  

	Verify that,
	1) stat(2) returns -1 and sets errno to EACCES if search permission is
	denied on a component of the path prefix.
	2) stat(2) returns -1 and sets errno to ENOENT if the specified file
	does not exists or empty string.
	3) stat(2) returns -1 and sets errno to EFAULT if pathname points
	outside user's accessible address space.
	4) stat(2) returns -1 and sets errno to ENAMETOOLONG if the pathname
	component is too long.
	5) stat(2) returns -1 and sets errno to ENOTDIR if the directory
	component in pathname is not a directory.

stat05

	Basic test for the stat05(2) system call. 

statfs01

	Basic test for the statfs(2) system call. 

statfs02  

	Testcase to check that statfs(2) sets errno correctly.


read01

	Basic test for the read(2) system call

read02  

	test 1: Does read return -1 if file descriptor is not valid, check for EBADF

	test 2: Check if read sets EISDIR, if the fd refers to a directory

	test 3: Check if read sets EFAULT, if buf is -1.

read03  

	Testcase to check that read() sets errno to EAGAIN

read04  

	Testcase to check if read returns the number of bytes read correctly.

umask01

	Basic test for the umask(2) system call. 

umask02  

	Check that umask changes the mask, and that the previous
	value of the mask is returned correctly for each value.

umask03  

	Check that umask changes the mask, and that the previous
	value of the mask is returned correctly for each value.



getgroups01

	Getgroups system call critical test 

getgroups02

	Basic test for getgroups(2) 

getgroups03  

	Verify that, getgroups() system call gets the supplementary group IDs
	of the calling process.

getgroups04  

	Verify that,
	getgroups() fails with -1 and sets errno to EINVAL if the size
	argument value is -ve.

gethostname01

	Basic test for gethostname(2)


getpgid01

	Testcase to check the basic functionality of getpgid().

getpgid02

	Testcase to check the basic functionality of getpgid().

getpgrp01
	Basic test for getpgrp(2)


getpriority01  

	Verify that getpriority() succeeds get the scheduling priority of 
	the current process, process group or user.


getpriority02  

	Verify that,
	1) getpriority() sets errno to ESRCH  if no process was located
	was located for 'which' and 'who' arguments.
	2) getpriority() sets errno to EINVAL if 'which' argument was
	not one of PRIO_PROCESS, PRIO_PGRP, or PRIO_USER.

getresgid01  

	Verify that getresgid() will be successful to get the real, effective
	and saved user id of the calling process.

getresgid02  

	Verify that getresgid() will be successful to get the real, effective
	and saved user ids after calling process invokes setregid() to change
	the effective/saved gids to that of specified user.

getresgid03  

	Verify that getresgid() will be successful to get the real, effective
	and saved user ids after calling process invokes setresgid() to change
	the effective gid to that of specified user.


getresuid01  

	Verify that getresuid() will be successful to get the real, effective
	and saved user id of the calling process.

getresuid02  

	Verify that getresuid() will be successful to get the real, effective
	and saved user ids after calling process invokes setreuid() to change
	the effective/saved uids to that of specified user.

getresuid03  

	Verify that getresuid() will be successful to get the real, effective
	and saved user ids after calling process invokes setresuid() to change
	the effective uid to that of specified user.


getsid01  

	call getsid() and make sure it succeeds

getsid02  

	call getsid() with an invalid PID to produce a failure


setfsgid01  

	Testcase to check the basic functionality of setfsgid(2) system
	call.

setfsuid01  

	Testcase to test the basic functionality of the setfsuid(2) system
	call.


setgid01

	Basic test for the setgid(2) system call. 

setgid02

	Testcase to ensure that the setgid() system call sets errno to EPERM


setgroups01

	Basic test for the setgroups(2) system call. 

setgroups02  

	Verify that,
	1. setgroups() fails with -1 and sets errno to EINVAL if the size
	argument value is > NGROUPS
	2. setgroups() fails with -1 and sets errno to EPERM if the
	calling process is not super-user.

setgroups03  

	Verify that, only root process can invoke setgroups() system call to
	set the supplementary group IDs of the process.


setpgid01	 	

	Basic test for setpgid(2) system call. 

setpgid02  

	Testcase to check that setpgid() sets errno correctly.

setpgid03  

	Test to check the error and trivial conditions in setpgid system call

setpriority01  

	set the priority for the test process lower.

setpriority02  

	test for an expected failure by trying to raise
	the priority for the test process while not having
	permissions to do so.

setpriority03  

	test for an expected failure by using an invalid
	PRIO value
	setpriority04  

setpriority04
	test for an expected failure by using an invalid
	process id


setpriority05 
	test for an expected failure by trying to change
	a process with an ID that is different from the
	test process

setregid01	 

	Basic test for the setregid(2) system call. 

setregid02  

	Test that setregid() fails and sets the proper errno values when a
	non-root user attempts to change the real or effective group id to a 
	value other than the current gid or the current effective gid. 

setregid03  

	Test setregid() when executed by a non-root user.

setregid04  

	Test setregid() when executed by root.

setresuid01  

	Test setresuid() when executed by root.

setresuid02  

	Test that a non-root user can change the real, effective and saved
	uid values through the setresuid system call.


setresuid03  

	Test that the setresuid system call sets the proper errno
	values when a non-root user attempts to change the real, effective or
	saved uid to a value other than one of the current uid, the current
	effective uid of the current saved uid.  Also verify that setresuid
	fails if an invalid uid value is given.

setreuid01	 	

	Basic test for the setreuid(2) system call. 

setreuid02  

	Test setreuid() when executed by root.

setreuid03  

	Test setreuid() when executed by an unprivileged user.


setreuid04  

	Test that root can change the real and effective uid to an
	unprivileged user.

setreuid05  

	Test the setreuid() feature, verifying the role of the saved-set-uid
	and setreuid's effect on it.

setreuid06  

	Test that EINVAL is set when setreuid is given an invalid user id.

setrlimit01  

	Testcase to check the basic functionality of the setrlimit system call.


setrlimit02  

	Testcase to test the different errnos set by setrlimit(2) system call.

setrlimit03  

	Test for EPERM when the super-user tries to increase RLIMIT_NOFILE
	beyond the system limit.

setsid01  

	Test to check the error and trivial conditions in setsid system call

setuid01

	Basic test for the setuid(2) system call. 

setuid02

	Basic test for the setuid(2) system call as root. 

setuid03  

	Test to check the error and trivial conditions in setuid

fs_perms

	Regression test for Linux filesystem permissions.
uname01

	Basic test for the uname(2) system call.  

uname02  

	Call uname() with an invalid address to produce a failure

uname03  

	Call uname() and make sure it succeeds
sysctl01  

	Testcase for testing the basic functionality of sysctl(2) system call.
	This testcase attempts to read the kernel parameters using
	sysctl({CTL_KERN, KERN_ }, ...) and compares it with the known
	values.

sysctl03  

	Testcase to check that sysctl(2) sets errno to EPERM correctly.


sysctl04  

	Testcase to check that sysctl(2) sets errno to ENOTDIR


sysctl05  

	Testcase to check that sysctl(2) sets errno to EFAULT

time01

	Basic test for the time(2) system call. 


time02  

	Verify that time(2) returns the value of time in seconds since
	the Epoch and stores this value in the memory pointed to by the parameter.

times01

	Basic test for the times(2) system call. 

times02  

	Testcase to test that times() sets errno correctly

times03  

	Testcase to check the basic functionality of the times() system call.

utime01  

	Verify that the system call utime() successfully sets the modification
	and access times of a file to the current time, if the times argument
	is null, and the user ID of the process is "root".

utime02  

	Verify that the system call utime() successfully sets the modification
	and access times of a file to the current time, under the following
	constraints,
	- The times argument is null.
	- The user ID of the process is not "root".
	- The file is owned by the user ID of the process.

utime03  

	Verify that the system call utime() successfully sets the modification
	and access times of a file to the current time, under the following
	constraints,
	- The times argument is null.
	- The user ID of the process is not "root".
	- The file is not owned by the user ID of the process.
	- The user ID of the process has write access to the file.


utime04  

	Verify that the system call utime() successfully sets the modification
	and access times of a file to the time specified by times argument, if
	the times argument is not null, and the user ID of the process is "root".


utime05  

	Verify that the system call utime() successfully sets the modification
	and access times of a file to the value specified by the times argument
	under the following constraints,
	- The times argument is not null,
	- The user ID of the process is not "root".
	- The file is owned by the user ID of the process.


utime06  

	1. Verify that the system call utime() fails to set the modification
	and access times of a file to the current time, under the following
	constraints,
	- The times argument is null.
	- The user ID of the process is not "root".
	- The file is not owned by the user ID of the process.
	- The user ID of the process does not have write access to the
	file.
	2. Verify that the system call utime() fails to set the modification
	and access times of a file if the specified file doesn't exist.

settimeofday01  

	Testcase to check the basic functionality of settimeofday().


settimeofday02  

	Testcase to check that settimeofday() sets errnos correctly.

stime01  

	Verify that the system call stime() successfully sets the system's idea
	of data and time if invoked by "root" user.

stime02  

	Verify that the system call stime() fails to set the system's idea
	of data and time if invoked by "non-root" user.

gettimeofday01     

	Testcase to check that gettimeofday(2) sets errno to EFAULT.



alarm01	 	

	Basic test for alarm(2). 

alarm02

	Boundary Value Test for alarm(2).

alarm03

	Alarm(2) cleared by a fork.

alarm04  

	Check that when an alarm request is made, the signal SIGALRM is received
	even after the process has done an exec().

alarm05  

	Check the functionality of the Alarm system call when the time input
	parameter is non zero.

alarm06  

	Check the functionality of the Alarm system call when the time input
	parameter is zero.

alarm07  

	Check the functionality of the alarm() when the time input
	parameter is non-zero and the process does a fork.

getegid01

	Basic test for getegid(2) 


geteuid01

	Basic test for geteuid(2) 


getgid01

	Basic test for getgid(2) 

getgid02  

	Testcase to check the basic functionality of getgid().

getgid03  

	Testcase to check the basic functionality of getegid().


getpid01

	Basic test for getpid(2) 


getpid02  

	Verify that getpid() system call gets the process ID of the of the
	calling process.


getppid01  

	Testcase to check the basic functionality of the getppid() syscall.


getuid01

	Basic test for getuid(2)

getuid02  

	Testcase to check the basic functionality of the geteuid() system call.

getuid03  

	Testcase to check the basic functionality of the getuid() system call.

nanosleep01  

	Verify that nanosleep() will be successful to suspend the execution
	of a process for a specified time.

nanosleep02  

	Verify that nanosleep() will be successful to suspend the execution
	of a process, returns after the receipt of a signal and writes the
	remaining sleep time into the structure.

nanosleep03  

	Verify that nanosleep() will fail to suspend the execution
	of a process for a specified time if interrupted by a non-blocked signal.

nanosleep04  

	Verify that nanosleep() will fail to suspend the execution
	of a process if the specified pause time is invalid.

